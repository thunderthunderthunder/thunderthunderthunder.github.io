---
tite: 可见性
description: java内置锁和j.u.c.locks.Lock保证可见性的区别
date: 2017-10-02
categories:
 - java
tags:
 - jmm
---

> java内置锁和j.u.c.locks.Lock保证可见性的区别

这两天读到CyclicBarrier的源码，这个类能管理若干个线程，知道这些线程都完成某些操作，才能继续向后执行。

它有一个构造方法：

```java
private int count;
private final Runnable barrierCommand;
public CyclicBarrier(int parties, Runnable barrierAction) {
        if (parties <= 0) throw new IllegalArgumentException();
        this.parties = parties;
        this.count = parties;
        this.barrierCommand = barrierAction;
    }
```

可以看到的是它的一个属性count初始值为线程数。
barrierCommand为这些线程执行完某些操作后，由最有一个线程执行改任务。

执行改任务的伪代码如下：

```java
private int dowait(boolean timed, long nanos) {
        final ReentrantLock lock = this.lock;
        lock.lock();
        try {
            //...
            int index = --count;
            if (index == 0) {
                barrierCommand.run();
        } finally {
            lock.unlock();
        }
        //...
```




## synchronized



## j.u.c.locks.Lock
