---
tite: 可见性
description: java内置锁和j.u.c.locks.Lock保证可见性的区别
date: 2017-10-02
categories:
 - java
tags:
 - jmm
---

> java内置锁和j.u.c.locks.Lock保证可见性的区别

这两天读到CyclicBarrier的源码，这个类能管理若干个线程，知道这些线程都完成某些操作，才能继续向后执行。

它有一个构造方法：

```java
private int count;
private final Runnable barrierCommand;
public CyclicBarrier(int parties, Runnable barrierAction) {
        if (parties <= 0) throw new IllegalArgumentException();
        this.parties = parties;
        this.count = parties;
        this.barrierCommand = barrierAction;
    }
```

可以看到的是它的一个属性count初始值为线程数。
barrierCommand为这些线程执行完某些操作后，由最有一个线程执行改任务。

执行改任务的伪代码如下：

```java
private int dowait(boolean timed, long nanos) {
        final ReentrantLock lock = this.lock;
        lock.lock();
        try {
            //...
            int index = --count;
            if (index == 0) {
                barrierCommand.run();
        } finally {
            lock.unlock();
        }
        //...
}
```
同步块是通过ReentrantLock加锁的，但是j.u.c.locks.Lock的实现类都是通过java代码层面实现的，不像java内置锁（synchronized）是通过jvm底层实现的，
而且count并没有定义成volatile，那它是怎么保证可见性的呢？

## synchronized

在由该关键字申明的同步块中，进入同步块时，线程会将主内存空间的数据刷入到线程的工作空间，退出同步块的时候，线程会将工作空间的数据刷入到主内存空间中，
这样就保证了两个线程互相可见（前提是这两个线程持有的是同一个锁对象）。这是通过jvm底层实现的，通过在指令前后插入强制刷新的指令。

## j.u.c.locks.Lock
