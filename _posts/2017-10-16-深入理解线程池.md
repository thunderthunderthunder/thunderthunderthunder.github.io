---
tite: 深入理解java线程池
description: 
date: 2017-10-16
categories:
 - java
tags:
 - concurrent
 - 并发
---

一般获取一个线程我们会通过Executors这个工具类。
最常用的就是这个方法：
```java
public static ExecutorService newFixedThreadPool(int nThreads) {
        return new ThreadPoolExecutor(nThreads, nThreads,
                                      0L, TimeUnit.MILLISECONDS,
                                      new LinkedBlockingQueue<Runnable>());
    }
```
对应到ThreadPoolExecutor就是一下这个构造方法
```java
public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue<Runnable> workQueue) {
        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
             Executors.defaultThreadFactory(), defaultHandler);
    }
    
public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue<Runnable> workQueue,
                              ThreadFactory threadFactory,
                              RejectedExecutionHandler handler) {
        if (corePoolSize < 0 ||
            maximumPoolSize <= 0 ||
            maximumPoolSize < corePoolSize ||
            keepAliveTime < 0)
            throw new IllegalArgumentException();
        if (workQueue == null || threadFactory == null || handler == null)
            throw new NullPointerException();
        this.corePoolSize = corePoolSize;
        this.maximumPoolSize = maximumPoolSize;
        this.workQueue = workQueue;
        this.keepAliveTime = unit.toNanos(keepAliveTime);
        this.threadFactory = threadFactory;
        this.handler = handler;
    }
```
从中可以看出线程池有以下属性：
```java
//核心线程数，当线程池接收到任务时，会new一个线程，知道线程数等于corePoolSize的大小
//这个数量的线程不会被中止，除非allowCoreThreadTimeOut这个属性为true
private volatile int corePoolSize;
//最大线程数，当任务队列满了的时候，会使用这里的线程，但最大不能超过maximumPoolSize
//超过该值将会被拒绝，拒绝策略由RejectedExecutionHandler决定
private volatile int maximumPoolSize;
//任务队列
private final BlockingQueue<Runnable> workQueue;
//线程最大空闲时间，超过该时间会中止
private volatile long keepAliveTime;
//线程生成器
private volatile ThreadFactory threadFactory;
//任务拒绝策略
private volatile RejectedExecutionHandler handler;
```
ThreadPoolExecutor中维护了一个AtomicInteger类型的属性，该属性记录了存活线程的数量和线程池的运行状态：
```java
private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));

//获取线程池的运行状态
private static int runStateOf(int c)     { return c & ~CAPACITY; }
//获取线程池中存活的线程数
private static int workerCountOf(int c)  { return c & CAPACITY; }
//根据传入的运行状态和线程数量组成ctl
private static int ctlOf(int rs, int wc) { return rs | wc; }
```
ThreadPoolExecutor最核心的方法是execute(Runnable)，接下来会详细的分析该方法的源码：
```java
//该方法主要分为3个步骤
public void execute(Runnable command) {
        if (command == null) //判空校验
            throw new NullPointerException();
        int c = ctl.get(); //获取ctl
        //第一个步骤，当前线程数小于核心线程数则启动一个新线程
        if (workerCountOf(c) < corePoolSize) { //如果当前线程数量小于核心线程数
            if (addWorker(command, true)) //启动一个工作线程
                return;
            c = ctl.get(); //启动失败，重新获取ctl。当多个线程并发提交任务时可能会启动失败
        }
        //第二个步骤：当前线程数大于等于核心线程数，则将任务提交到任务队列中
        if (isRunning(c) && workQueue.offer(command)) {
            int recheck = ctl.get();
            if (! isRunning(recheck) && remove(command)) //如果线程池状态为关闭，则移除任务，并用拒绝策略处理该任务
                reject(command);
            else if (workerCountOf(recheck) == 0) //如果线程池没有关闭，但是线程数为0，则新开一个线程
                addWorker(null, false);
        }
        //第三个步骤：当前线程已达核心线程数，任务队列已满，则启动最大线程数来处理任务，如果已到最大线程数，则拒绝该任务
        else if (!addWorker(command, false))
            reject(command);
    }
```
其中的addWorker方法会new一个Worker，并将该工作者添加到workers中：
```java
private boolean addWorker(Runnable firstTask, boolean core) {
        retry:
        for (;;) {
            int c = ctl.get();
            int rs = runStateOf(c); //获取线程池状态
            if (rs >= SHUTDOWN && !(rs == SHUTDOWN && firstTask == null && !workQueue.isEmpty()))
                return false;
            for (;;) {
                int wc = workerCountOf(c);
                if (wc >= CAPACITY || wc >= (core ? corePoolSize : maximumPoolSize))
                    return false;
                if (compareAndIncrementWorkerCount(c)) //cas将当前线程数加1
                    break retry; //成功则跳出for循环
                c = ctl.get();  
                if (runStateOf(c) != rs) //如果线程池当前状态和之前的不一样，则需要跳到最外层的for循环，重新判断线程池状态
                    continue retry;
            }
        }
        boolean workerStarted = false;
        boolean workerAdded = false;
        Worker w = null;
        try {
            //构造一个Worker，这个是ThreadPoolExecutor的内部类，实现了Runnable接口，继承了AQS
            //Worker持有一个线程，该线程就是通过ThreadFactory构造的，并将自身作为Runnable传递给Thread
            //所以说当Thread启动的时候运动的是Worker的run方法
            w = new Worker(firstTask);
            final Thread t = w.thread;
            if (t != null) {
                final ReentrantLock mainLock = this.mainLock;
                mainLock.lock();
                try {
                    int rs = runStateOf(ctl.get());
                    if (rs < SHUTDOWN || (rs == SHUTDOWN && firstTask == null)) {
                        if (t.isAlive()) //检查线程的启动状态
                            throw new IllegalThreadStateException();
                        //将工作者添加到workers中，该属性存的是线程池中所有存活的工作者
                        workers.add(w);
                        int s = workers.size();
                        //设置largestPoolSize，这个线程池的属性表示的是该线程池最大时到达的线程数
                        if (s > largestPoolSize)
                            largestPoolSize = s;
                        //表示添加到workers成功
                        workerAdded = true;
                    }
                } finally {
                    mainLock.unlock();
                }
                if (workerAdded) { //线程成功添加到workers中
                    t.start(); //启动该线程
                    workerStarted = true;
                }
            }
        } finally {
            if (! workerStarted) //如果线程启动失败，则将该Woker从workers中移除
                addWorkerFailed(w);
        }
        return workerStarted;
    }
```
正如上面所说的，创建的线程最终运行的是Worker的run方法，下面看一下Worker的run方法：
```java
public void run() {
            runWorker(this); //将Worker自身传递给runWorker方法
        }

final void runWorker(Worker w) {
        Thread wt = Thread.currentThread();
        Runnable task = w.firstTask;
        w.firstTask = null;
        //将state设置为0，将exclusiveOwnerThread设置为null
        //先进行释放
        w.unlock(); // allow interrupts
        boolean completedAbruptly = true;
        try {
            //先执行firstTask，如果firstTask为null，则通过getTask从任务队列中获取任务
            while (task != null || (task = getTask()) != null) {
                //将state设置为1，将exclusiveOwnerThread设置为当前线程
                w.lock();
                if ((runStateAtLeast(ctl.get(), STOP) || //线程池状态大于等于STOP
                    (Thread.interrupted() && runStateAtLeast(ctl.get(), STOP))) &&
                    !wt.isInterrupted()) //当前线程打断标示位还没有设置
                    wt.interrupt(); //打断当前线程    
                try {
                    beforeExecute(wt, task); //模版方法，没有具体实现
                    Throwable thrown = null;
                    try {
                        task.run(); //运行任务
                    } catch (RuntimeException x) {
                        thrown = x; throw x;
                    } catch (Error x) {
                        thrown = x; throw x;
                    } catch (Throwable x) {
                        thrown = x; throw new Error(x);
                    } finally {
                        afterExecute(task, thrown); //模版方法
                    }
                } finally {
                    task = null;
                    //该工作者完成任务数量加1
                    w.completedTasks++;
                    //将state设置为0，将exclusiveOwnerThread设置为null
                    //先进行释放
                    w.unlock();
                }
            }
            completedAbruptly = false;
        } finally {
            processWorkerExit(w, completedAbruptly);
        }
    }
```
## 线程池关闭
```java
public void shutdown() {
        final ReentrantLock mainLock = this.mainLock;
        mainLock.lock();
        try {
            //检查线程访问权限
            checkShutdownAccess();
            //将线程池的状态设置为SHUTDOWN
            advanceRunState(SHUTDOWN);
            //中断空闲的线程，其实就是在getTask方法中阻塞的线程，而在getTask方法中会捕获中断异常
            interruptIdleWorkers();
            //ScheduledThreadPoolExecutor会使用实现这个方法
            onShutdown();
        } finally {
            mainLock.unlock();
        }
        tryTerminate();
    }
```
shutdown方法中主要涉及4个方法，onShutdown这个方法需要子类去实现，主要看checkShutdownAccess，advanceRunState，interruptIdleWorkers，
tryTerminate这4个方法
```java
    private void interruptIdleWorkers(boolean onlyOne) {
        final ReentrantLock mainLock = this.mainLock;
        mainLock.lock();
        try {
            for (Worker w : workers) {
                Thread t = w.thread;
                //这里使用w.tryLock()是因为可能该Worker正在处理任务，所以尝试获取锁，获取不到不会挂起该线程，而是选择忽略
                if (!t.isInterrupted() && w.tryLock()) {
                    try {
                        t.interrupt();
                    } catch (SecurityException ignore) {
                    } finally {
                        w.unlock();
                    }
                }
                if (onlyOne)
                    break;
            }
        } finally {
            mainLock.unlock();
        }
    }
```

