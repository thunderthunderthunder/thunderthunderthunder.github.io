---
tite: 深入理解java线程池
description: 
date: 2017-10-16
categories:
 - java
tags:
 - concurrent
 - 并发
---

一般获取一个线程我们会通过Executors这个工具类。
最常用的就是这个方法：
```java
public static ExecutorService newFixedThreadPool(int nThreads) {
        return new ThreadPoolExecutor(nThreads, nThreads,
                                      0L, TimeUnit.MILLISECONDS,
                                      new LinkedBlockingQueue<Runnable>());
    }
```
对应到ThreadPoolExecutor就是一下这个构造方法
```java
public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue<Runnable> workQueue) {
        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
             Executors.defaultThreadFactory(), defaultHandler);
    }
    
public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue<Runnable> workQueue,
                              ThreadFactory threadFactory,
                              RejectedExecutionHandler handler) {
        if (corePoolSize < 0 ||
            maximumPoolSize <= 0 ||
            maximumPoolSize < corePoolSize ||
            keepAliveTime < 0)
            throw new IllegalArgumentException();
        if (workQueue == null || threadFactory == null || handler == null)
            throw new NullPointerException();
        this.corePoolSize = corePoolSize;
        this.maximumPoolSize = maximumPoolSize;
        this.workQueue = workQueue;
        this.keepAliveTime = unit.toNanos(keepAliveTime);
        this.threadFactory = threadFactory;
        this.handler = handler;
    }
```
从中可以看出线程池有以下属性：
```java
//核心线程数，当线程池接收到任务时，会new一个线程，知道线程数等于corePoolSize的大小
//这个数量的线程不会被中止，除非allowCoreThreadTimeOut这个属性为true
private volatile int corePoolSize;
//最大线程数，当任务队列满了的时候，会使用这里的线程，但最大不能超过maximumPoolSize
//超过该值将会被拒绝，拒绝策略由RejectedExecutionHandler决定
private volatile int maximumPoolSize;
//任务队列
private final BlockingQueue<Runnable> workQueue;
//线程最大空闲时间，超过该时间会中止
private volatile long keepAliveTime;
//线程生成器
private volatile ThreadFactory threadFactory;
//任务拒绝策略
private volatile RejectedExecutionHandler handler;
```
ThreadPoolExecutor中维护了一个AtomicInteger类型的属性，该属性记录了存活线程的数量和线程池的运行状态：
```java
private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));

//获取线程池的运行状态
private static int runStateOf(int c)     { return c & ~CAPACITY; }
//获取线程池中存活的线程数
private static int workerCountOf(int c)  { return c & CAPACITY; }
//根据传入的运行状态和线程数量组成ctl
private static int ctlOf(int rs, int wc) { return rs | wc; }
```
ThreadPoolExecutor最核心的方法是execute(Runnable)，接下来会详细的分析该方法的源码：
```java
public void execute(Runnable command) {
        if (command == null)
            throw new NullPointerException();
        int c = ctl.get();
        //如果当前线程数小于核心线程数，则
        int c = ctl.get();
        if (workerCountOf(c) < corePoolSize) {
            if (addWorker(command, true))
                return;
            c = ctl.get();
        }
        if (isRunning(c) && workQueue.offer(command)) {
            int recheck = ctl.get();
            if (! isRunning(recheck) && remove(command))
                reject(command);
            else if (workerCountOf(recheck) == 0)
                addWorker(null, false);
        }
        else if (!addWorker(command, false))
            reject(command);
    }
```
